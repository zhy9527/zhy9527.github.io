<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[go结构体组合函数]]></title>
    <url>%2F2020%2F04%2F18%2Fgo%2Fstructfunc%2F</url>
    <content type="text"><![CDATA[原文 结构体定义上面我们说过Go的指针和C的不同，结构体也是一样的。Go是一门删繁就简的语言，一切令人困惑的特性都必须去掉。 简单来讲，Go提供的结构体就是把使用各种数据类型定义的不同变量组合起来的高级数据类型。闲话不多说，看例子: 1234type Rect struct &#123; width float64 length float64&#125; 上面我们定义了一个矩形结构体，首先是关键是type表示要定义一个新的数据类型了，然后是新的数据类型名称Rect，最后是struct关键字，表示这个高级数据类型是结构体类型。在上面的例子中，因为width和length的数据类型相同，还可以写成如下格式： 123type Rect struct &#123; width, length float64&#125; 好了，来用结构体干点啥吧，计算一下矩形面积。 12345678910111213141516package mainimport ( &quot;fmt&quot;)type Rect struct &#123; width, length float64&#125;func main() &#123; var rect Rect rect.width = 100 rect.length = 200 fmt.Println(rect.width * rect.length)&#125; 从上面的例子看到，其实结构体类型和基础数据类型使用方式差不多，唯一的区别就是结构体类型可以通过.来访问内部的成员。包括给内部成员赋值和读取内部成员值。 在上面的例子中，我们是用var关键字先定义了一个Rect变量，然后对它的成员赋值。我们也可以使用初始化的方式来给Rect变量的内部成员赋值。 123456789101112131415package mainimport ( &quot;fmt&quot;)type Rect struct &#123; width, length float64&#125;func main() &#123; var rect = Rect&#123;width: 100, length: 200&#125; fmt.Println(rect.width * rect.length)&#125; 当然如果你知道结构体成员定义的顺序，也可以不使用key:value的方式赋值，直接按照结构体成员定义的顺序给它们赋值。 1234567891011121314151617181920package mainimport ( &quot;fmt&quot;)type Rect struct &#123; width, length float64&#125;func main() &#123; var rect = Rect&#123;100, 200&#125; fmt.Println(&quot;Width:&quot;, rect.width, &quot;* Length:&quot;, rect.length, &quot;= Area:&quot;, rect.width*rect.length)&#125;// 输出结果为// Width: 100 * Length: 200 = Area: 20000 结构体参数传递方式我们说过，Go函数的参数传递方式是值传递，这句话对结构体也是适用的。 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot;)type Rect struct &#123; width, length float64&#125;func double_area(rect Rect) float64 &#123; rect.width *= 2 rect.length *= 2 return rect.width * rect.length&#125;func main() &#123; var rect = Rect&#123;100, 200&#125; fmt.Println(double_area(rect)) fmt.Println(&quot;Width:&quot;, rect.width, &quot;Length:&quot;, rect.length)&#125;// 上面的例子输出为:// 80000// Width: 100 Length: 200 也就说虽然在double_area函数里面我们将结构体的宽度和长度都加倍，但仍然没有影响main函数里面的rect变量的宽度和长度。 结构体组合函数上面我们在main函数中计算了矩形的面积，但是我们觉得矩形的面积如果能够作为矩形结构体的“内部函数”提供会更好。这样我们就可以直接说这个矩形面积是多少，而不用另外去取宽度和长度去计算。现在我们看看结构体“内部函数”定义方法： 1234567891011121314151617181920package mainimport ( &quot;fmt&quot;)type Rect struct &#123; width, length float64&#125;func (rect Rect) area() float64 &#123; return rect.width * rect.length&#125;func main() &#123; var rect = Rect&#123;100, 200&#125; fmt.Println(&quot;Width:&quot;, rect.width, &quot;Length:&quot;, rect.length, &quot;Area:&quot;, rect.area())&#125; 咦？这个是什么“内部方法”，根本没有定义在Rect数据类型的内部啊？ 确实如此，我们看到，虽然main函数中的rect变量可以直接调用函数area()来获取矩形面积，但是area()函数确实没有定义在Rect结构体内部，这点和C语言的有很大不同。Go使用组合函数的方式来为结构体定义结构体方法。我们仔细看一下上面的area()函数定义。 首先是关键字func表示这是一个函数，第二个参数是结构体类型和实例变量，第三个是函数名称，第四个是函数返回值。这里我们可以看出area()函数和普通函数定义的区别就在于area()函数多了一个结构体类型限定。这样一来Go就知道了这是一个为结构体定义的方法。 这里需要注意一点就是定义在结构体上面的函数(function)一般叫做方法(method)。 结构体和指针我们在指针一节讲到过，指针的主要作用就是在函数内部改变传递进来变量的值。对于上面的计算矩形面积的例子，我们可以修改一下代码如下： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)type Rect struct &#123; width, length float64&#125;func (rect *Rect) area() float64 &#123; return rect.width * rect.length&#125;func main() &#123; var rect = new(Rect) rect.width = 100 rect.length = 200 fmt.Println(&quot;Width:&quot;, rect.width, &quot;Length:&quot;, rect.length, &quot;Area:&quot;, rect.area())&#125; 上面的例子中，使用了new函数来创建一个结构体指针rect，也就是说rect的类型是Rect，结构体遇到指针的时候，你不需要使用去访问结构体的成员，直接使用.引用就可以了。所以上面的例子中我们直接使用rect.width=100 和rect.length=200来设置结构体成员值。因为这个时候rect是结构体指针，所以我们定义area()函数的时候结构体限定类型为*Rect。 其实在计算面积的这个例子中，我们不需要改变矩形的宽或者长度，所以定义area函数的时候结构体限定类型仍然为Rect也是可以的。如下： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)type Rect struct &#123; width, length float64&#125;func (rect Rect) area() float64 &#123; return rect.width * rect.length&#125;func main() &#123; var rect = new(Rect) rect.width = 100 rect.length = 200 fmt.Println(&quot;Width:&quot;, rect.width, &quot;Length:&quot;, rect.length, &quot;Area:&quot;, rect.area())&#125; 这里Go足够聪明，所以rect.area()也是可以的。 至于使不使用结构体指针和使不使用指针的出发点是一样的，那就是你是否试图在函数内部改变传递进来的参数的值。再举个例子如下： 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot;)type Rect struct &#123; width, length float64&#125;func (rect *Rect) double_area() float64 &#123; rect.width *= 2 rect.length *= 2 return rect.width * rect.length&#125;func main() &#123; var rect = new(Rect) rect.width = 100 rect.length = 200 fmt.Println(*rect) fmt.Println(&quot;Double Width:&quot;, rect.width, &quot;Double Length:&quot;, rect.length, &quot;Double Area:&quot;, rect.double_area()) fmt.Println(*rect)&#125;// 这个例子的输出是：&#123;100 200&#125;// Double Width: 200 Double Length: 400 Double Area: 80000// &#123;200 400&#125; 结构体内嵌类型我们可以在一个结构体内部定义另外一个结构体类型的成员。例如iPhone也是Phone，我们看下例子： 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot;)type Phone struct &#123; price int color string&#125;type IPhone struct &#123; phone Phone model string&#125;func main() &#123; var p IPhone p.phone.price = 5000 p.phone.color = &quot;Black&quot; p.model = &quot;iPhone 5&quot; fmt.Println(&quot;I have a iPhone:&quot;) fmt.Println(&quot;Price:&quot;, p.phone.price) fmt.Println(&quot;Color:&quot;, p.phone.color) fmt.Println(&quot;Model:&quot;, p.model)&#125;// 输出结果为// I have a iPhone:// Price: 5000// Color: Black// Model: iPhone 5 在上面的例子中，我们在结构体IPhone里面定义了一个Phone变量phone，然后我们可以像正常的访问结构体成员一样访问phone的成员数据。但是我们原来的意思是“iPhone也是(is-a)Phone”，而这里的结构体IPhone里面定义了一个phone变量，给人的感觉就是“iPhone有一个(has-a)Phone”，挺奇怪的。当然Go也知道这种方式很奇怪，所以支持如下做法： 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot;)type Phone struct &#123; price int color string&#125;type IPhone struct &#123; Phone model string&#125;func main() &#123; var p IPhone p.price = 5000 p.color = &quot;Black&quot; p.model = &quot;iPhone 5&quot; fmt.Println(&quot;I have a iPhone:&quot;) fmt.Println(&quot;Price:&quot;, p.price) fmt.Println(&quot;Color:&quot;, p.color) fmt.Println(&quot;Model:&quot;, p.model)&#125;// 输出结果为// I have a iPhone:// Price: 5000// Color: Black// Model: iPhone 5 在这个例子中，我们定义IPhone结构体的时候，不再定义Phone变量，直接把结构体Phone类型定义在那里。然后IPhone就可以像访问直接定义在自己结构体里面的成员一样访问Phone的成员。 上面的例子中，我们演示了结构体的内嵌类型以及内嵌类型的成员访问，除此之外，假设结构体A内部定义了一个内嵌结构体B，那么A同时也可以调用所有定义在B上面的函数。 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( &quot;fmt&quot;)type Phone struct &#123; price int color string&#125;func (phone Phone) ringing() &#123; fmt.Println(&quot;Phone is ringing...&quot;)&#125;type IPhone struct &#123; Phone model string&#125;func main() &#123; var p IPhone p.price = 5000 p.color = &quot;Black&quot; p.model = &quot;iPhone 5&quot; fmt.Println(&quot;I have a iPhone:&quot;) fmt.Println(&quot;Price:&quot;, p.price) fmt.Println(&quot;Color:&quot;, p.color) fmt.Println(&quot;Model:&quot;, p.model) p.ringing()&#125;// 输出结果为：// I have a iPhone:// Price: 5000// Color: Black// Model: iPhone 5// Phone is ringing... 接口我们先看一个例子，关于Nokia手机和iPhone手机都能够打电话的例子。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot;)type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123; fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func main() &#123; var nokia NokiaPhone nokia.call() var iPhone IPhone iPhone.call()&#125; 我们定义了NokiaPhone和IPhone，它们都有各自的方法call()，表示自己都能够打电话。但是我们想一想，是手机都应该能够打电话，所以这个不算是NokiaPhone或是IPhone的独特特点。否则iPhone不可能卖这么贵了。 再仔细看一下接口的定义，首先是关键字type，然后是接口名称，最后是关键字interface表示这个类型是接口类型。在接口类型里面，我们定义了一组方法。 Go语言提供了一种接口功能，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口，不一定非要显式地声明要去实现哪些接口啦。比如上面的手机的call()方法，就完全可以定义在接口Phone里面，而NokiaPhone和IPhone只要实现了这个接口就是一个Phone。 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot;)type Phone interface &#123; call()&#125;type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123; fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func main() &#123; var phone Phone phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()&#125; 在上面的例子中，我们定义了一个接口Phone，接口里面有一个方法call()，仅此而已。然后我们在main函数里面定义了一个Phone类型变量，并分别为之赋值为NokiaPhone和IPhone。然后调用call()方法，输出结果如下： I am Nokia, I can call you!I am iPhone, I can call you!以前我们说过，Go语言式静态类型语言，变量的类型在运行过程中不能改变。但是在上面的例子中，phone变量好像先定义为Phone类型，然后是NokiaPhone类型，最后成为了IPhone类型，真的是这样吗？ 原来，在Go语言里面，一个类型A只要实现了接口X所定义的全部方法，那么A类型的变量也是X类型的变量。在上面的例子中，NokiaPhone和IPhone都实现了Phone接口的call()方法，所以它们都是Phone，这样一来是不是感觉正常了一些。 我们为Phone添加一个方法sales()，再来熟悉一下接口用法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( &quot;fmt&quot;)type Phone interface &#123; call() sales() int&#125;type NokiaPhone struct &#123; price int&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;func (nokiaPhone NokiaPhone) sales() int &#123; return nokiaPhone.price&#125;type IPhone struct &#123; price int&#125;func (iPhone IPhone) call() &#123; fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func (iPhone IPhone) sales() int &#123; return iPhone.price&#125;func main() &#123; var phones = [5]Phone&#123; NokiaPhone&#123;price: 350&#125;, IPhone&#123;price: 5000&#125;, IPhone&#123;price: 3400&#125;, NokiaPhone&#123;price: 450&#125;, IPhone&#123;price: 5000&#125;, &#125; var totalSales = 0 for _, phone := range phones &#123; totalSales += phone.sales() &#125; fmt.Println(totalSales)&#125;// 输出结果：// 14200 上面的例子中，我们定义了一个手机数组，然后计算手机的总售价。可以看到，由于NokiaPhone和IPhone都实现了sales()方法，所以它们都是Phone类型，但是计算售价的时候，Go会知道调用哪个对象实现的方法。 接口类型还可以作为结构体的数据成员。 假设有个败家子，iPhone没有出的时候，买了好几款Nokia，iPhone出来后，又买了好多部iPhone，老爸要来看看这小子一共花了多少钱。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( &quot;fmt&quot;)type Phone interface &#123; sales() int&#125;type NokiaPhone struct &#123; price int&#125;func (nokiaPhone NokiaPhone) sales() int &#123; return nokiaPhone.price&#125;type IPhone struct &#123; price int&#125;func (iPhone IPhone) sales() int &#123; return iPhone.price&#125;type Person struct &#123; phones []Phone name string age int&#125;func (person Person) total_cost() int &#123; var sum = 0 for _, phone := range person.phones &#123; sum += phone.sales() &#125; return sum&#125;func main() &#123; var bought_phones = [5]Phone&#123; NokiaPhone&#123;price: 350&#125;, IPhone&#123;price: 5000&#125;, IPhone&#123;price: 3400&#125;, NokiaPhone&#123;price: 450&#125;, IPhone&#123;price: 5000&#125;, &#125; var person = Person&#123;name: &quot;Jemy&quot;, age: 25, phones: bought_phones[:]&#125; fmt.Println(person.name) fmt.Println(person.age) fmt.Println(person.total_cost())&#125;// 这个例子纯为演示接口作为结构体数据成员，如有雷同，纯属巧合。这里面我们定义了一个Person结构体，结构体内部定义了一个手机类型切片。另外我们定义了Person的total_cost()方法用来计算手机花费总额。输出结果如下：// Jemy// 25// 14200 小结Go的结构体和接口的实现方法可谓删繁就简，去除了很多别的语言令人困惑的地方，而且学习难度也不大，很容易上手。不过由于思想比较独到，也有可能会有人觉得功能太简单而无用，这个就各有看法了，不过在逐渐的使用过程中，我们会慢慢领悟到这种设计所带来的好处，以及所避免的问题。]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go 变量笔记]]></title>
    <url>%2F2020%2F04%2F10%2Fgo%2Fvar%2F</url>
    <content type="text"><![CDATA[指定变量类型，如果没有初始化，则变量默认为零值。 1var v_name v_type 根据值自行判定变量类型。 1var v_name = value 因式分解关键字 12345// 这种因式分解关键字的写法一般用于声明全局变量var ( vname1 v_type1 vname2 v_type2) 初始化声明 12// 这种不带声明格式的只能在函数体中出现g, h := 123, &quot;hello&quot; 空白标识符 123空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享常用的GoLang包工具]]></title>
    <url>%2F2020%2F03%2F10%2Fgo%2Fcustompack%2F</url>
    <content type="text"><![CDATA[| 包名 | 链接地址 | 备注 || Machinery异步队列 | https://github.com/RichardKnop/machinery || Mqtt通信 | github.com/eclipse/paho.mqtt.golang | go文档http://www.eclipse.org/paho/clients/golang || 微信开发 | https://github.com/chanxuehong/wechat || fasthttp包 | github.com/valyala/fasthttp || 数据库操作包 | https://github.com/gocraft/dbr || mysql db链式操作 | https://github.com/gohouse/gorose || glide包管理工具 | https://zhuanlan.zhihu.com/p/27994151 || 文件配置包 | github.com/spf13/viper || cli应用执行程序包 | github.com/spf13/cobra || redis包 命令式操作 | github.com/garyburd/redigo/redis || redis包 便捷操作 | github.com/go-redis/redis || 日志包 | https://www.jianshu.com/p/5fac8bed4505 || 日志包 | https://github.com/zbindenren/logrus_mail | 邮件通知logrus的hook || gin Api文档包 | https://github.com/swaggo/gin-swagger || govalidator 参数验证器 | github.com/asaskevich/govalidator || json编解码库 | github.com/json-iterator/go || json web token | https://github.com/dgrijalva/jwt-go || 类型转换 | github.com/Unknwon/com || 优雅的重启Http服务 | github.com/fvbock/endless | 目前只支持linux环境下使用，零时间重启 || 权限控制 | github.com/mikespook/gorbac || WebSocket包 | github.com/gorilla/websocket || 定时任务包 | github.com/robfig/cron || CloudXNS-DDNS | https://github.com/zwh8800/cloudxns-ddns | 动态域名客户端 docker 镜 || Restful和gprc相互转换 | https://github.com/grpc-ecosystem/grpc-gateway | example =&gt; https://githubcom/go-up/go-example || proto构建Go代码工具 | github.com/tuneinc/truss | 用于RPC协议文档生| Api网关 | https://github.com/fagongzi/gateway || GO直播服务器 | https://github.com/gwuhaolin/livego || RabbitMQ包 | https://github.com/streadway/amqp || gin中文文档 | https://github.com/skybebe/gin-doc-c || http限流 | https://github.com/didip/tollboot || ORM包 | https://github.com/go-sql-driver/mysq |]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac启动Mysql，停止Mysql，重启Mysql]]></title>
    <url>%2F2020%2F02%2F14%2Fmysql%2FmysqlStart%2F</url>
    <content type="text"><![CDATA[启动mysql1$ sudo /usr/local/mysql/support-files/mysql.server start 密码输入电脑登录密码 停止mysql1$ sudo /usr/local/mysql/support-files/mysql.server stop 重启mysql1$ sudo /usr/local/mysql/support-files/mysql.server restart]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 npm 迁移到 yarn]]></title>
    <url>%2F2019%2F12%2F14%2Fjs%2Fnpmtoyarn%2F</url>
    <content type="text"><![CDATA[迁移文档地址(https://yarn.bootcss.com/docs/migrating-from-npm/)CLI commands comparison（命令比较） npm (v5) Yarn npm install yarn install (N/A) yarn install –flat (N/A) yarn install –har npm install –no-package-lock yarn install –no-lockfile (N/A) yarn install –pure-lockfile npm install [package] –save yarn add [package] npm install [package] –save-dev yarn add [package] –dev (N/A) yarn add [package] –peer npm install [package] –save-optional yarn add [package] –optional npm install [package] –save-exact yarn add [package] –exact (N/A) yarn add [package] –tilde npm install [package] –global yarn global add [package] npm update –global yarn global upgrade npm rebuild yarn add –force npm uninstall [package] yarn remove [package] npm cache clean yarn cache clean [package] rm -rf node_modules &amp;&amp; npm install yarn upgrade npm version major yarn version –major npm version minor yarn version –minor npm version patch yarn version –patch]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery on() click事件在iphone上失效的解决办法]]></title>
    <url>%2F2019%2F10%2F06%2Fcss%2Fphone6jianrong%2F</url>
    <content type="text"><![CDATA[每逢秋去冬来是人去花又别，叹一声缘分不该如此难求 &lt;&lt;青衣&gt;&gt; 前言问题页面上有一动态添加的元素，用jq的on()添加click事件，在iphone上无效，但在浏览器和安卓上没问题。 123$(document).on(&apos;click&apos;, &apos;#btn&apos;, function () &#123; alert(&apos;Hello！&apos;)&#125;) 解决方法给该元素添加如下样式；对于点击的对象，拥有cursor:pointer;这个样式，即鼠标放上去，能够出现“手”型的图标才能视为可以使用点击事件。 123#btn &#123; cursor:pointer&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS12以上微信内置浏览器下键盘收起底部空白的问题]]></title>
    <url>%2F2019%2F09%2F30%2Fwehcat%2Fwxcheck-input-empty%2F</url>
    <content type="text"><![CDATA[BUG 表现Bug表现：在IOS12以上的系统下，微信打开链接点击输入框获取焦点后虚拟键盘自动弹出，输入内容后收起键盘，原来弹出键盘的位置一片空白，页面没有自动适应整个屏幕。 解决方案在公共js文件下对设备进行判断，如果为IOS设备则全局处理该问题，即在当前页面滚动的位置上下滚动1px的距离即可实现页面的自适应！ 123456789101112131415161718let ua = window.navigator.userAgent;if(!!ua.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/))&#123; //$alert('ios端'); document.body.addEventListener('focusout', () =&gt; &#123; var currentPosition,timer; var speed=1; timer=setInterval(function()&#123; currentPosition=document.documentElement.scrollTop || document.body.scrollTop; currentPosition-=speed; window.scrollTo(0,currentPosition);//页面向上滚动 currentPosition+=speed; window.scrollTo(0,currentPosition);//页面向下滚动 clearInterval(timer); &#125;,100); &#125;)&#125;else if(ua.indexOf('Android') &gt; -1 || ua.indexOf('Adr') &gt; -1) &#123; //$alert('android端');&#125;]]></content>
      <categories>
        <category>weChat</category>
      </categories>
      <tags>
        <tag>weChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我会死在龙背墙后]]></title>
    <url>%2F2019%2F09%2F14%2Flives%2Fquanminmuji%2F</url>
    <content type="text"><![CDATA[在电影院看的这部电影，看到最后哭的稀里哗啦，吃的悬疑片的安利，却被煽情煽的一塌糊涂，谁让我就是吃这一套呢…亲情杀我一向是抗拒不了的… 电影用不断闪回倒放的方式逐渐引出事情的真相，真相是出乎人的意料的，父爱如山，是什么样的爱让父亲以这种方式让女儿脱罪，记得最清楚的就是孙红雷在法庭上喊出的那句话“我会死在龙背墙后，我会死在你手里！” 电影里解释了龙背墙，远古的南龙王老来得子，所以对小龙王宠爱有加。但小龙王淘气任性，到处惹祸，直到有一天，他真的闯出大祸，失手烧掉了天庭的神坛。慌乱中的小龙王回到家里，天庭自然不会放过他，南龙王为了救儿子，他冒充小龙王，趴在神龙山下，接受雷电的击打，眼看着父亲被烧成遍体鳞伤，奄奄一息，小龙王悔恨愧疚，他一下冲出来要承担这个惩罚，南龙王为了儿子封口，便一头撞向一旁的金刚壁，当场死去。养不教，父之过， 南龙王认为自己死得其所，死后他的 尸体便化作龙背山。经过这场灾难之 后，小龙王幡然醒悟，终生恪守本分，与人为善，后人将龙背山改称为龙背墙，是因为这面墙挡住了小龙王所有的罪行。 父爱如山，撑起了子女的所有过错和磨难。 孙红雷演的父亲就是这样，他想尽办法让郭富城认为是他杀了人，他要为女儿顶罪，其实他有其他的办法，他的能力可以让其他人心甘情愿的顶罪，为什么他要自己去呢？在我看来，是为了教育女儿，用自己的死去告诉她，要认错，要改过… “他用生命换来你的自由 不是让你偷生，而是让你重生。”]]></content>
      <categories>
        <category>有关风月</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页适配 iPhoneX，就是这么简单]]></title>
    <url>%2F2019%2F09%2F06%2Fcss%2FhbuildIphoneX%2F</url>
    <content type="text"><![CDATA[《无名》水上鸳鸯，云中翡翠。忧佳相随，风雨无悔。引喻山河，指日可诚。生则同襟，死则同穴。 -云霜这是一首哀怨缠绵的情诗，哀怨在那种生死相随忧患与共的深情 文章原文 前言iPhoneX 取消了物理按键，改成底部小黑条，这一改动导致网页出现了比较尴尬的屏幕适配问题。对于网页而言，顶部（刘海部位）的适配问题浏览器已经做了处理，所以我们只需要关注底部与小黑条的适配问题即可（即常见的吸底导航、返回顶部等各种相对底部 fixed 定位的元素）。 笔者通过查阅了一些官方文档，以及结合实际项目中的一些处理经验，整理了一套简单的适配方案分享给大家，希望对大家有所帮助，以下是处理前后效果图： 适配之前需要了解的几个新知识安全区域安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响，如下图蓝色区域：也就是说，我们要做好适配，必须保证页面可视、可操作区域是在安全区域内。 更详细说明，参考文档：Human Interface Guidelines - iPhoneX viewport-fitiOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值： contain: 可视窗口完全包含网页内容（左图） cover：网页内容完全覆盖可视窗口（右图） auto：默认值，跟 contain 表现一致注意：网页默认不添加扩展的表现是 viewport-fit=contain，需要适配 iPhoneX 必须设置 viewport-fit=cover，这是适配的关键步骤。更详细说明，参考文档：viewport-fit-descriptor env() 和 constant()iOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量： safe-area-inset-left：安全区域距离左边边界距离 safe-area-inset-right：安全区域距离右边边界距离 safe-area-inset-top：安全区域距离顶部边界距离 safe-area-inset-bottom：安全区域距离底部边界距离 这里我们只需要关注 safe-area-inset-bottom 这个变量，因为它对应的就是小黑条的高度（横竖屏时值不一样）。 注意：当 viewport-fit=contain 时 env() 是不起作用的，必须要配合 viewport-fit=cover 使用。对于不支持env() 的浏览器，浏览器将会忽略它。 在这之前，笔者使用的是 constant()，后来，官方文档加了这么一段注释（坑）：The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward. 这就意味着，之前使用的 constant() 在 iOS11.2 之后就不能使用的，但我们还是需要做向后兼容，像这样： 123/* 注意：env() 跟 constant() 需要同时存在，而且顺序不能换。 */padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS &lt; 11.2 */padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS &gt;= 11.2 */ 更详细说明，参考文档：Designing Websites for iPhone X 如何适配了解了以上所说的几个知识点，接下来我们适配的思路就很清晰了。 第一步：设置网页在可视窗口的布局方式新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口： 1&lt;meta name="viewport" content="width=device-width, viewport-fit=cover"&gt; 前面也有提到过，只有设置了 viewport-fit=cover，才能使用 env()。 第二步：页面主体内容限定在安全区域内这一步根据实际页面场景选择，如果不设置这个值，可能存在小黑条遮挡页面最底部内容的情况。 1234body &#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125; 第三步：fixed 元素的适配类型一：fixed 完全吸底元素（bottom = 0），比如下图这两种情况： 12345678910/* 可以通过加内边距 padding 扩展高度： */&#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125;/* 或者通过计算函数 calc 覆盖原来高度： */&#123; height: calc(60px(假设值) + constant(safe-area-inset-bottom)); height: calc(60px(假设值) + env(safe-area-inset-bottom));&#125; 注意，这个方案需要吸底条必须是有背景色的，因为扩展的部分背景是跟随外容器的，否则出现镂空情况。 还有一种方案就是，可以通过新增一个新的元素（空的颜色块，主要用于小黑条高度的占位），然后吸底元素可以不改变高度只需要调整位置，像这样： 1234&#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom);&#125; 空的颜色块： 12345678&#123; position: fixed; bottom: 0; width: 100%; height: constant(safe-area-inset-bottom); height: env(safe-area-inset-bottom); background-color: #fff;&#125; 类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理： 1234&#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom);&#125; 或者，你也可以通过计算函数 calc 覆盖原来 bottom 值： 1234&#123; bottom: calc(50px(假设值) + constant(safe-area-inset-bottom)); bottom: calc(50px(假设值) + env(safe-area-inset-bottom));&#125; 你也可以使用 @supports 隔离兼容样式写到这里，我们常见的两种类型的 fixed 元素适配方案已经了解了吧。如果我们只希望 iPhoneX 才需要新增适配样式，我们可以配合 @supports 来隔离兼容样式，当然这个处理对页面展示实际不会有任何影响： 123456@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) &#123; div &#123; margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom); &#125;&#125; 写在最后以上几种方案仅供参考，笔者认为，现阶段适配处理起来是有点折腾，但是至少能解决，具体需要根据页面实际场景，在不影响用户体验与操作的大前提下不断尝试与探索，才能更完美的适配。我是优秀文章的搬运工，感谢您的阅读，本文由 凹凸实验室 版权所有。如若转载，请注明出处：凹凸实验室（https://aotu.io/notes/2017/11/27/iphonex/）]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery Validate 自定义验证方法的实现]]></title>
    <url>%2F2019%2F09%2F05%2Fjs%2FjqueryValidate%2F</url>
    <content type="text"><![CDATA[《奋斗》如果我一辈子穷困，你还会爱我吗？如果你一辈子努力，即使穷困我也还爱你。 最近做后台验证，jQuery Validate 提供的无法满足，所以需要写自定义验证方法，以前也有写，但是没记录 表单部分123456789101112131415&lt;script src="/lib/jquery.js"&gt;&lt;/script&gt;&lt;script src="/dist/jquery.validate.min.js"&gt;&lt;/script&gt;&lt;script src="/dist/localization/messages_zh.js"&gt;&lt;/script&gt;&lt;form class="cmxform" id="commentForm" method="get" action=""&gt; &lt;fieldset&gt; &lt;legend&gt;请输入姓名&lt;/legend&gt; &lt;p&gt; &lt;label for="password"&gt;password &lt;/label&gt; &lt;input id="password" name="password" type="password" required&gt; &lt;/p&gt; &lt;p&gt; &lt;input class="submit" type="submit" value="Submit"&gt; &lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt; 下面是js验证部分 12345678910111213141516171819202122$.validator.setDefaults(&#123; submitHandler: function () &#123; console.log("提交成功") &#125;&#125;);$().ready(function () &#123; $("#commentForm").validate(&#123; onkeyup: function(element) &#123; $(element).valid(); &#125;, // 首次监听表单数据变化，触发验证 rules:&#123; password: &#123; coustom: ['a','f'] &#125; &#125; &#125;); // 密码验证 $.validator.addMethod("coustom", function(value, element) &#123; var tel = /^(?![a-zA-Z]+$)(?![A-Z0-9]+$)(?![A-Z\W_!@#$%^&amp;*`~()-+=]+$)(?![a-z0-9]+$)(?![a-z\W_!@#$%^&amp;*`~()-+=]+$)(?![0-9\W_!@#$%^&amp;*`~()-+=]+$)[a-zA-Z0-9\W_!@#$%^&amp;*`~()-+=]&#123;8,16&#125;$/; // 必须包含大小写字母、数字且为8-16个字符 return this.optional(element) || (tel.test(value)); &#125;, "必须包含大小写字母、数字且为8-16个字符");&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[liunx 常用命令]]></title>
    <url>%2F2019%2F08%2F10%2Fother%2FliunxCommand%2F</url>
    <content type="text"></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序多图上传，包含压缩，以base64格式]]></title>
    <url>%2F2019%2F08%2F01%2Fwehcat%2Fwechat-upload%2F</url>
    <content type="text"><![CDATA[背景需求：小程序多图上传，转base64上传，后来发现图片太大，上传失败思路：获取原图临时路径，用canvas重绘图片并生成压缩后临时路径，生成base64格式主要方法： wx.chooseImage 调用微信选择图片api wx.getImageInfo 获取图片详情信息 wx.createCanvasContext 创建canvas wx.getFileSystemManager().readFile 生成base64格式图片 效果如下 WXML内容123456789101112131415161718192021&lt;view class='content'&gt; &lt;view class='img-box'&gt; &lt;view class='img-list'&gt; &lt;block wx:for="&#123;&#123;fileBase64&#125;&#125;" wx:key=""&gt; &lt;view class='img-item'&gt; &lt;image src='data:image/jpg;base64,&#123;&#123;item&#125;&#125;' data-index='&#123;&#123;index&#125;&#125;' class='img' mode='aspectFill'&gt;&lt;/image&gt; &lt;view class="upload_progress" style='opacity: &#123;&#123;0.7*(1-item.upload_percent/100)&#125;&#125;' wx:if="&#123;&#123;item.upload_percent &lt; 100&#125;&#125;"&gt;&#123;&#123;item.upload_percent&#125;&#125;%&lt;/view&gt; &lt;view class='delete' data-index='&#123;&#123;index&#125;&#125;' catchtap='deleteImg'&gt;&lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;view class='chooseimg' bindtap='uploadDetailImage' wx:if="&#123;&#123; uploadMax === -1 || uploadMax &gt; tempFiles.length &#125;&#125;"&gt; &lt;view class="weui-uploader__input-box"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;canvas canvas-id="canvas0" style="width:&#123;&#123;cWidth0&#125;&#125;px;height:&#123;&#123;cHeight0&#125;&#125;px;position: absolute;left:-1000px;top:-1000px;"&gt;&lt;/canvas&gt;&lt;canvas canvas-id="canvas1" style="width:&#123;&#123;cWidth1&#125;&#125;px;height:&#123;&#123;cHeight1&#125;&#125;px;position: absolute;left:-1000px;top:-1000px;"&gt;&lt;/canvas&gt;&lt;canvas canvas-id="canvas2" style="width:&#123;&#123;cWidth2&#125;&#125;px;height:&#123;&#123;cHeight2&#125;&#125;px;position: absolute;left:-1000px;top:-1000px;"&gt;&lt;/canvas&gt;&lt;canvas canvas-id="canvas3" style="width:&#123;&#123;cWidth3&#125;&#125;px;height:&#123;&#123;cHeight3&#125;&#125;px;position: absolute;left:-1000px;top:-1000px;"&gt;&lt;/canvas&gt;&lt;canvas canvas-id="canvas4" style="width:&#123;&#123;cWidth4&#125;&#125;px;height:&#123;&#123;cHeight4&#125;&#125;px;position: absolute;left:-1000px;top:-1000px;"&gt;&lt;/canvas&gt; CCS篇幅较长，在最后面 注意事项/有坑未填： 上传图片重复没有过滤 最多只能上传5张图片 图片太大、绘制太长，会出现空白 js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 选取图片的方法 uploadDetailImage: function (e) &#123; let that = this; const success = (res) =&gt; &#123; // 返回原图临时路径,res.tempFilePaths res.tempFilePaths.forEach((item, index) =&gt; &#123; // 获取图片的信息 wx.getImageInfo(&#123; src: item, success: function (res) &#123; //----------绘制图形并取出图片路径-------------- var ratio = 2; var canvasWidth = res.width //图片原始长宽 var canvasHeight = res.height while (canvasWidth &gt; 600 || canvasHeight &gt; 600) &#123;// 保证宽高在400以内 canvasWidth = Math.trunc(res.width / ratio) canvasHeight = Math.trunc(res.height / ratio) ratio++; &#125; that.setData(&#123; ['cWidth'+index]: canvasWidth, ['cHeight' + index]: canvasHeight &#125;) // 创建canvas var ctx = wx.createCanvasContext('canvas' + index) ctx.drawImage(res.path, 0, 0, canvasWidth, canvasHeight) ctx.draw(false, setTimeout(function () &#123; // 把当前画布指定区域的内容导出生成指定大小的图片 wx.canvasToTempFilePath(&#123; canvasId: 'canvas' + index, fileType: 'jpg', success: function (res) &#123; // 生成base64 wx.getFileSystemManager().readFile(&#123; filePath: res.tempFilePath, encoding: 'base64', success: res =&gt; &#123; var fileBase64 = that.data.fileBase64 fileBase64.push(res.data); that.setData(&#123; fileBase64: fileBase64 &#125;) &#125; &#125;) &#125;, fail: function (res) &#123; console.log(res.errMsg) &#125; &#125;) &#125;, 500)) // 留给绘制时间 &#125; &#125;) &#125;) &#125; // 调用微信选择图片api wx.chooseImage(&#123; count, sizeType, sourceType, success &#125;) &#125;, // 删除图片 deleteImg(e) &#123; let index = e.currentTarget.dataset.index let arr = this.data.fileBase64 arr.splice(index, 1) this.setData(&#123; fileBase64: arr &#125;) &#125; CSS内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109.content &#123; width: 100%; background-color: #fff;&#125;.content .img-list::after &#123; content: ''; display: block; clear: both; visibility: hidden; height: 0;&#125;.content .img-item &#123; float: left; width: 160rpx; height: 160rpx; margin: 0 18rpx 18rpx 0; border-radius: 8rpx; position: relative; /* padding: 8rpx; */ /* border: 1rpx solid #f5222d; */ /* box-sizing: border-box; */&#125;.content .img-item .delete &#123; width: 30rpx; height: 30rpx; position: absolute; right: -10rpx; top: -10rpx; text-align: right; vertical-align: top; z-index: 2; background-size: 30rpx auto; background-color: #fff; border: 4rpx solid #fff; border-radius: 50%; background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg width='16' height='16' viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Ccircle fill-opacity='.4' fill='%23404040' cx='8' cy='8' r='8'/%3E%3Cpath d='M11.898 4.101a.345.345 0 0 0-.488 0L8 7.511l-3.411-3.41a.345.345 0 0 0-.488.488l3.411 3.41-3.41 3.412a.345.345 0 0 0 .488.488L8 8.487l3.411 3.411a.345.345 0 0 0 .488-.488L8.488 8l3.41-3.412a.344.344 0 0 0 0-.487z' fill='%23FFF'/%3E%3C/g%3E%3C/svg%3E");&#125;.content .img-item .img &#123; display: block; width: 100%; height: 100%; border-radius: 8rpx;&#125;/* 上传进度 */.upload_progress &#123; position: absolute; top: 0; right: 0; /* opacity: 0.7; */ border-radius: 8rpx; background-color: #000; color: #fff; width: 158rpx; height: 158rpx; text-align: center; line-height: 158rpx; font-size: 24rpx;&#125;.chooseimg &#123; background-color: #fff;&#125;.weui-uploader__input-box &#123; float: left; position: relative; margin-right: 9px; margin-bottom: 9px; width: 160rpx; height: 160rpx; border: 1px dashed #ebebeb; border-radius: 8rpx;&#125;.weui-uploader__input-box:before &#123; width: 2px; height: 39px;&#125;.weui-uploader__input-box:after &#123; width: 39px; height: 2px;&#125;.weui-uploader__input-box:after, .weui-uploader__input-box:before &#123; content: " "; position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); background-color: #d9d9d9;&#125;.tips &#123; color: #666; font-size: 24rpx; padding-bottom: 20rpx;&#125;.img-box &#123; width: 100%; padding: 20rpx 10rpx 0 28rpx;&#125;]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>WeChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用vue package]]></title>
    <url>%2F2019%2F07%2F14%2Fjs%2Fvuepackage%2F</url>
    <content type="text"><![CDATA[UI框架 vant，文档地址适合移动端、电商等场景 Element-UI,文档地址饿了么前端框架、适合后台管理系统、中台等场景 iview，文档地址非常优秀的一款组件，比element-ui漂亮，但是table感觉没有element-ui好用 Ant Design Vue, 文档地址 VUEX vuex-persistedstatevuex数据持久化、刷新数据依然保留 网络请求 axios flyio 插件 vue-awesome-swiper幻灯片 v-distpicker省市区联动]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iphone上input不易聚焦]]></title>
    <url>%2F2019%2F06%2F30%2Fjs%2Fuserselect%2F</url>
    <content type="text"><![CDATA[iphone上input不易聚焦父元素加个-webkit-user-select:text;才有效，单独子元素即使加-webkit-user-select:text也无效 123&lt;div style="-webkit-user-select:text;"&gt; &lt;input type="text" placeholder="请输入用户名" /&gt;&lt;/div&gt; 1&gt; [user-select CSS属性，控制着用户能否选中文本。](https://developer.mozilla.org/zh-CN/docs/Web/CSS/user-select) 语法user-select有以下几个值： none元素及其子元素的文本不可选中。 请注意这个Selection 对象可以包含这些元素。 从Firefox 21开始， none 表现的像 -moz-none，因此可以使用 -moz-user-select: text 在子元素上重新启用选择。 autoauto的计算值确定如下： 在 ::before 和 ::after 伪元素上，计算属性是 none如果元素是可编辑元素，则计算值是 contain否则，如果此元素的父元素的 user-select 的计算值为 all, 计算值则为 all否则，如果此元素的父级上的 user-select 的计算值为 none, 计算值则为 none否则，计算值则为 text text用户可以选择文本。 -moz-none元素和子元素的文本将显示为无法选择它们。 请注意， Selection 对象可以包含这些元素。 可以使用 -moz-user-select: text. 在子元素上重新启用选择。 从Firefox 21开始，none 表现得像 -moz-none. all在一个HTML编辑器中，当双击子元素或者上下文时，那么包含该子元素的最顶层元素也会被选中。 containelement (IE-specific alias)允许选择在元素内开始; 但是，选择将包含在该元素的边界内。 仅在Internet Explorer中受支持。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序端运用vant]]></title>
    <url>%2F2019%2F06%2F19%2Fjs%2FvantWeapp%2F</url>
    <content type="text"><![CDATA[Vant Weapp Vant Weapp 是移动端 Vue 组件库 Vant 的小程序版本，两者基于相同的视觉规范，提供一致的 API 接口，助力开发者快速搭建小程序应用。 文档地址]]></content>
      <categories>
        <category>weChat</category>
      </categories>
      <tags>
        <tag>weChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序阻止事件冒泡]]></title>
    <url>%2F2019%2F05%2F30%2Fwehcat%2FwechatEvent%2F</url>
    <content type="text"><![CDATA[微信小程序阻止事件冒泡 使用 catch 不用bindbind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。 如在下边这个例子中，点击 inner view 会先后调用handleTap3和handleTap2(因为tap事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发handleTap2，点击 outer view 会触发handleTap1。 123456789&lt;view id="outer" bindtap="handleTap1"&gt; outer view &lt;view id="middle" catchtap="handleTap2"&gt; middle view &lt;view id="inner" bindtap="handleTap3"&gt; inner view &lt;/view&gt; &lt;/view&gt;&lt;/view 在方法最后加上return false]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>WeChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue中应用weui]]></title>
    <url>%2F2019%2F05%2F16%2Fjs%2Fweuivue%2F</url>
    <content type="text"><![CDATA[在vue中使用weui的两种方式 cdn形式引入这种方式直接在html引入即可 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; &lt;title&gt;SFOPEN&lt;/title&gt; &lt;link rel="shortcut icon" href="favicon.ico" /&gt; &lt;link rel="stylesheet" href="https://res.wx.qq.com/open/libs/weui/1.1.3/weui.min.css"&gt; &lt;script type="text/javascript" src="https://res.wx.qq.com/open/libs/weuijs/1.1.4/weui.min.js"&gt;&lt;/script&gt; &lt;style&gt; .weui-dialog__btn_primary&#123;color: #1131fe&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 在本地引入有些情况不适用cdn的形式引入，就需要下载到本地引入 1234// main.js// 引入weui文件，并且把weui对象绑定到window对象上，方便全局使用import './comm/css/weui.min.css'window.weui = require('./comm/js/weui.min.js').weui]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重，删除数组指定值]]></title>
    <url>%2F2019%2F04%2F30%2Fjs%2Farray-algorithm%2F</url>
    <content type="text"><![CDATA[最近在做一个自定义复选框+全选/全不选功能，涉及到一些数组的处理,自定义复选框 数组去重123456789uniq: function(array) &#123; var temp = []; //一个新的临时数组 for (var i = 0; i &lt; array.length; i++) &#123; if (temp.indexOf(array[i]) == -1) &#123; temp.push(array[i]); &#125; &#125; return temp;&#125; 1234// es6中新增的数据结构Setconst set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4] 删除指定数组1234567// 数组移除值remove: function(array, val) &#123; var index = array.indexOf(val); if (index &gt; -1) &#123; array.splice(index, 1); &#125;&#125; 数组排序123456789// 数组移除值var arr = new Array(6) arr[0] = "10" arr[1] = "5" arr[2] = "40" arr[3] = "25" arr[4] = "1000" arr[5] = "1"console.log(arr.sort((a,b)=&gt;&#123;return b-a&#125;))]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义复选框+全选/全不选]]></title>
    <url>%2F2019%2F04%2F30%2Fjs%2Fcheckout%2F</url>
    <content type="text"><![CDATA[True mastery of any skill takes a lifetime.对任何技能的掌握都需要一生的刻苦操练 最近在做一个自定义复选框+全选/全不选功能，项目基于vue，现在整理如下 大致思路 声明一个空的数组checked，数据为list 选中：把选中的项的id push进checked; 取消选中：判断当前id是否在checked中，若存在删除当前id 全选功能: 遍历数组，取到所有id，push进checked 全不选：checked重置为空数组 全选按钮状态：判断checked数组的长度是否和数据list长度一致，若一致则为全选状态，则给class加active 复选框状态：用indexOf是否大于-1判断当前id是否存在checked中，若大于-1，则给class加active 自定义全选功能代码123456789101112&lt;!-- 全选按钮 --&gt;&lt;div class="check all" :class="list.length == currChecked.length ?'active':''" @click="checkBoxAll"&gt;全选&lt;/div&gt;&lt;!-- 复选框 --&gt;&lt;div class="check" :class="currChecked.indexOf(item.id) &gt; -1 ? 'active':'a'" @click="checkBox(currChecked,item.id)"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536// data: &#123; list: [], // 全部选中的值 currChecked: [] // 当前已选中的复选框&#125;,methods: &#123; // 点击复选框 checkBox: function(array, id) &#123; if (array.indexOf(id) == -1) &#123; array.push(id); &#125; else &#123; this.remove(array, id); &#125; &#125;, // 全选按钮 checkBoxAll: function() &#123; let currChecked = this.currChecked let list = this.list if (currChecked.length == list.length) &#123; currChecked = []; &#125; else &#123; currChecked = []; for (var i = 0; i &lt; list.length; i++) &#123; currChecked.push(list[i].id); &#125; &#125; return currChecked; &#125;, // 数组移除值 remove: function(array, val) &#123; var index = array.indexOf(val); if (index &gt; -1) &#123; array.splice(index, 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传的2中方式，包含图片压缩]]></title>
    <url>%2F2019%2F04%2F30%2Fjs%2Fupload%2F</url>
    <content type="text"><![CDATA[代码摘自自己项目，项目框架是VUE，这里只说明功能实现，具体知识点请去MDN查看 图片转base64上传1&lt;input type="file" name="pic" id="pic" class="upload-btn" @change="uploadImg($event,'front')" accept="image/*" /&gt; 看下面代码，我们先看下FileReader对象： FileReader，查看介绍， FileReader 异步读取存储在用户计算机上的文件 当 FileReader 读取文件的方式为 readAsArrayBuffer, readAsBinaryString, readAsDataURL 或者 readAsText 的时候，会触发一个 load 事件。从而可以使用 FileReader.onload 属性对该事件进行处理。 这里会用到load属性 和readAsDataURL()方法 123456789uploadImg(e,type) &#123; let that = this let file = e.target.files[0] let reader = new FileReader() reader.readAsDataURL(file) reader.onload = function(e) &#123; // 当 FileReader 读取文件的方式为 readAsArrayBuffer, readAsBinaryString, readAsDataURL 或者 readAsText 的时候，会触发一个 load 事件 console.log(this.result) // 生成base64 &#125;&#125; 运用formData文件流上传1&lt;input type="file" name="pic" id="pic" class="upload-btn" @change="uploadImg($event,'front')" accept="image/*" /&gt; 这里会用到URL对象和formData对象，包含了图片压缩，代码注释中会说明一些自己的理解，若有偏颇，欢迎指正 URL对象相关内容请移步这里 formData对象请移步这里,formData我的理解是可以用ajax形式模拟form表单发送数据 图片压缩我们单独一个模块说明 123456789101112131415161718192021222324252627282930313233343536373839// 上传身份证图片 uploadImg(e,type) &#123; let that = this let file = e.target.files[0] lrz(file,&#123;quality: 0.6,width: 800&#125;) .then(function (rst) &#123; // 压缩成功会执行，这里的rst是压缩后图片的结果，我看了下大概压缩率能达到70%，10MB可以压缩到2MB console.log(rst); if (type == 'front')&#123; that.frontImgUrl = URL.createObjectURL(rst.file) // 这里我的理解是生成了一个图片的url that.frontImg = rst.file // 这是要发送给后端的数据 &#125; else &#123; that.backImgUrl = URL.createObjectURL(rst.file) that.backImg = rst.file &#125; &#125;) .catch(function (err) &#123; // 处理失败会执行 console.log(err) &#125;) &#125;, submit() &#123; let that = this // 创建FormData对象，并且把要传给后端的参数append进去 let formdata = new FormData(); formdata.append('id',patient.id); formdata.append('frontImg',this.frontImg); formdata.append('backImg',this.backImg); // Fetch是我封装的axios，这里可以忽略，这里重要的就是组装formdata数据 Fetch(&#123; url: "/api/xxxxx", method: "post", data: formdata &#125;).then(response =&gt; &#123; that.$router.push("aaa"); &#125;).catch(error =&gt; &#123; console.log(error); &#125;); &#125; 图片压缩 图片压缩应该是图片上传必然会遇到的问题，如果图片过大，上传慢且容易失败。我们遇到的问题是图片太大后端无法响应。 因为以前用过这个压缩库，所以这次拿出来说下，也比较简单 图片压缩代码github地址请点击 参数配置, 这里也讲的很清楚，不在赘述 12345678910111213lrz(this.files[0],&#123; // 这里会涉及到&#125;).then(function (rst) &#123; // 处理成功会执行 console.log(rst);&#125;).catch(function (err) &#123; // 处理失败会执行&#125;).always(function () &#123; // 不管是成功失败，都会执行&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序checkbox样式修改]]></title>
    <url>%2F2019%2F04%2F30%2Fwehcat%2Fwxcheck%2F</url>
    <content type="text"><![CDATA[原文 微信小程序checkbox样式修改1234567891011121314151617181920212223242526/*checkbox 整体大小 */checkbox &#123; width: 240rpx; height: 90rpx;&#125;/*checkbox 选项框大小 */checkbox .wx-checkbox-input &#123; width: 50rpx; height: 50rpx;&#125;/*checkbox选中后样式 */checkbox .wx-checkbox-input.wx-checkbox-input-checked &#123; background: #FF525C;&#125;/*checkbox选中后图标样式 */checkbox .wx-checkbox-input.wx-checkbox-input-checked::before &#123; width: 28rpx; height: 28rpx; line-height: 28rpx; text-align: center; font-size: 22rpx; color: #fff; background: transparent; transform: translate(-50%, -50%) scale(1); -webkit-transform: translate(-50%, -50%) scale(1);&#125; 效果如下]]></content>
      <categories>
        <category>weChat</category>
      </categories>
      <tags>
        <tag>weChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些令人难忘的框架]]></title>
    <url>%2F2019%2F04%2F29%2Fcss%2Fframework%2F</url>
    <content type="text"><![CDATA[JquerygreensockaltTemplate]]></content>
      <categories>
        <category>framework</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var、const、let区别]]></title>
    <url>%2F2019%2F04%2F19%2Fjs%2Fjsvar%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXJS学习笔记]]></title>
    <url>%2F2019%2F04%2F19%2Fjs%2Frxjs%2F</url>
    <content type="text"></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp使用记录]]></title>
    <url>%2F2019%2F04%2F18%2Fjs%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp介绍gulp是一个前端自动化构建工具，前端开发者可以使用它来处理常见任务: 搭建web服务器 文件保存时自动重载浏览器 使用css预处理器如Sass、LESS 优化资源，比如压缩CSS、JavaScript、压缩图片、合并文件 资源文件加版本号，刷新加载最新资源，保证资源文件实时更新 gulp入门指南 这部分内容来源于中文官方文档 全局安装 gulp： 1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装，这里为了举例安装gulp和gulp-clean，gulp-clean可以用来清空指定文件夹： 1$ npm install --save-dev gulp gulp-clean 在项目根目录下创建一个名为 gulpfile.js 的文件，点击可以查看gulp-clean使用方法： 12345678910var gulp = require('gulp')、 clean = require('gulp-clean') //清空文件夹,这里gulp.task('default', function() &#123; // 将你的默认的任务代码放在这&#125;);//清除dist文件夹gulp.task('clean',function()&#123; return gulp.src('dist', &#123;read: false&#125;) .pipe(clean());&#125;) 运行gulp： 1$ gulp 默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。想要单独执行特定的任务（task），请输入 gulp &lt;task&gt; &lt;othertask&gt;： 1$ gulp clean 接下来介绍下gulp相关的API，gulp的API有.src、.watch、.dest、.task。 gulp API 文档这里只简单介绍用法，和自己理解，官方文档讲解的更为详细，如果想深入学习，请移步官方文档 gulp.src(globs[, options]) 匹配想要处理的文件，例如： 1gulp.src('client/js/*.js') // 对clent/js下面的所有js文件进行处理 gulp.dest(path[, options]) dest就是要把处理完的文件放到指定位置，例如： 12gulp.src('client/js/*.js') // 对clent/js下面的所有js文件进行处理 .pipe(gulp.dest("dist/js/")); // 把处理完的文件放到`dist/js/`这个目录下面 因为有同事问过pipe方法，这里顺便提下。可以给他理解成一个管道，文件通过管道流入，可能有很多管道相连，每个管道处理不同的事物，a管道负责压缩js，b管道负责修改文件名为jquery.min.js，最后处理完就是压缩后的文件名为jquery.min.js的文件 关于pipe可以点击这里查看stream.pipe()，具体不在阐述。 gulp.task(name[, deps], fn) task定义任务，你要做什么，就是用它定义，例如要定义一个压缩js的任务，代码如下 12345678var gulp = require('gulp'), // gulp基础库 uglify = require('gulp-uglify') //压缩Js// 压缩JSgulp.task('uglifyJs',function()&#123; // 定义名为uglifyJs的任务，用来压缩js gulp.src("src/content/js/**/*.js") // 需要压缩的文件是src目录下 .pipe(uglify()) // 压缩js .pipe(gulp.dest("dist/content/js/")); // 压缩完成后放到dist目录下&#125;) 如果想执行这个任务，在终端输入以下命令： 1$ gulp uglifyJs gulp.watch(glob[, opts], tasks) 监听文件变化，如下代码/js/目录下的文件有任何变化，都会执行function 123gulp.watch('js/**/*.js', function(event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');&#125;); 常用插件及说明123456789101112gulp-sass // SCSS编译gulp-sourcemaps // SCSS地图gulp-clean // 清空文件夹gulp-clean-css // 压缩CSSgulp-uglify // 压缩Jsgulp-concat // 合并文件gulp-rev // 文件加版本号gulp-rev-collector // 替换html中资源文件gulp-minify-html // 压缩htmlgulp-replace // 替换html中的内容gulp-modify-css-urls // 修改css中url路径gulp-rename // 重命名文件 实战代码是自己项目中，根据需求配置的，有点乱，如有不明白的，欢迎留言 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193'use strict';var gulp = require('gulp'), //基础库 scss = require('gulp-sass'), //SCSS编译 sourcemaps = require('gulp-sourcemaps'), //SCSS地图 clean = require('gulp-clean'), //清空文件夹 cleanCss = require('gulp-clean-css'), //压缩CSS uglify = require('gulp-uglify'), //压缩Js concat = require('gulp-concat'), //合并文件 rev = require('gulp-rev'), //文件加版本号 revCollector = require('gulp-rev-collector'), //替换html文件 minifyHTML = require('gulp-minify-html'), //压缩html replace = require('gulp-replace'), //替换html内容 // browserSync = require('browser-sync').create(), // // reload = browserSync.reload, // modifyCssUrls = require('gulp-modify-css-urls'), //修改css中url路径 rename = require('gulp-rename'); //重命名文件var jsSrc = [ // 压缩js按照次序合并 'src/content/js/base_dev/config.js', 'src/content/js/base_dev/ajax.js', 'src/content/js/base_dev/cookie.js', 'src/content/js/base_dev/jiao.js', 'src/content/js/base_dev/log.js', 'src/content/js/base_dev/second-page.js', 'src/content/js/base_dev/storage.js', 'src/content/js/base_dev/string.js', 'src/content/js/base_dev/template-helper.js', 'src/content/js/base_dev/tools.js', 'src/content/js/base_dev/common.js', 'src/content/js/base_dev/tongji.js', // 'src/content/js/base_dev/wechat.js' ], revSrc = [ // 加版本号的资源 'dist/**', '!dist/**/*.html', '!dist/content/swiper/**', '!dist/content/mobiscroll/**', '!dist/content/font/**', '!dist/**/*.json', '!dist/**/*.ico', '!dist/**/*.map', ];// 将你的默认的任务代码放在这gulp.task('default',['clean','copyDist','cleanAvail','rev','cleanCss','uglifyJs','revCollector'], function() &#123;&#125;);// 编译Scssgulp.task('scss',function()&#123; return gulp.src('src/content/scss/*.scss') .pipe(sourcemaps.init()) .pipe(scss().on('error',scss.logError)) .pipe(sourcemaps.write()) .pipe(gulp.dest('src/content/css/'));&#125;)// 合并jsgulp.task('concatJs', function() &#123; return gulp.src(jsSrc) .pipe(concat('global.js')) //合并所有js到global.js .pipe(gulp.dest('src/content/js/base/')) //输出main.js到文件夹&#125;);// 监听任务gulp.task('watch',function()&#123; var watcher = gulp.watch(['src/content/scss/**','src/index.html','src/content/js/base_dev/*.js'], ['scss','concatJs']); watcher.on('change', function(event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...'); &#125;);&#125;)//清除文件夹gulp.task('clean',function()&#123; return gulp.src('dist', &#123;read: false&#125;) .pipe(clean());&#125;)// 压缩CSSgulp.task('cleanCss',['rev'],function()&#123; gulp.src("dist/content/css/*.css") // .pipe(rename(&#123; // dirname: "../dist/content/css/", // basename: "shu", // prefix: "", // suffix: ".min", // extname: ".css" // &#125;)) .pipe(cleanCss()) .pipe(gulp.dest("dist/content/css/"));&#125;)// 压缩CSSgulp.task('cleanCssToV2',function()&#123; gulp.src("src/content/css/*.css") // 替换css文件中的images路径 .pipe(modifyCssUrls(&#123; modify: function (url, filePath) &#123; if (url.indexOf('../images') != -1) &#123; return url.replace('../images','/images/v3') &#125; if (url.indexOf('../font') != -1) &#123; return url.replace('../font','../../fonts/v3') &#125; &#125;, &#125;)) .pipe(rename(&#123; dirname: "../../wap_v2/css/v3", prefix: "", suffix: ".min", extname: ".css" &#125;)) .pipe(cleanCss()) .pipe(gulp.dest('src'));&#125;)// 压缩JSgulp.task('uglifyJs',['rev'],function()&#123; gulp.src("dist/content/js/**/*.js") .pipe(uglify()) .pipe(gulp.dest("dist/content/js/"));&#125;)// 文件加版本号gulp.task('rev',['cleanAvail'],function()&#123; return gulp.src(revSrc) .pipe(rev()) .pipe(gulp.dest('dist')) .pipe(rev.manifest()) .pipe(gulp.dest('dist'));&#125;)// 替换html中的文件路径，并压缩htmlgulp.task('revCollector', ['rev'], function () &#123; return gulp.src(['dist/rev-manifest.json', 'dist/**/*.html']) .pipe( revCollector() ) .pipe( minifyHTML(&#123; empty:true, spare:true &#125;) ) .pipe( gulp.dest('dist') );&#125;);// 复制dist文件夹gulp.task('copyDist',['clean'],function()&#123; return gulp.src('src/**') .pipe(gulp.dest('dist'))&#125;)// 清除线上不用文件，scss，base-dev等gulp.task('cleanAvail',['copyDist'],function()&#123; return gulp.src(['dist/content/scss','dist/content/js/base_dev']) .pipe(clean());&#125;)// 构建gulp.task('build',['clean','copyDist','cleanAvail','cleanCss','rev','revCollector'],function()&#123;&#125;)// 静态服务器// gulp.task('browser-sync', function() &#123;// browserSync.init(&#123;// server: &#123;// baseDir: "src/index.html"// &#125;// &#125;);// &#125;);// 代理// gulp.task('browser-sync', function() &#123;// browserSync.init(&#123;// proxy: "你的域名或IP"// &#125;);// &#125;);// 生成对应文件到v2gulp.task('fileToV2',['cssToV2','jsToV2','imgToV2','htmlToV2'],function()&#123;&#125;)gulp.task('cssToV2',function()&#123; gulp.src("dist/content/css/*.css") // 替换css文件中的images路径 .pipe(modifyCssUrls(&#123; modify: function (url, filePath) &#123; if (url.indexOf('../images') != -1) &#123; return url.replace('../images','/images/v3') &#125; if (url.indexOf('../font') != -1) &#123; return url.replace('../font','../../fonts/v3') &#125; &#125;, &#125;)) .pipe(gulp.dest('../wap_v2/css/v3'));&#125;)gulp.task('jsToV2',function()&#123; gulp.src(["!dist/content/js/cycle/**","!dist/content/js/index/**","dist/content/js/**/*.js"]) .pipe(gulp.dest('../wap_v2/js/v3'));&#125;)gulp.task('imgToV2',function()&#123; gulp.src("dist/content/images/**") .pipe(gulp.dest('../wap_v2/images/v3'));&#125;)gulp.task('htmlToV2',function()&#123; gulp.src("dist/**/*.html") // 替换css文件中的images路径 .pipe(replace('../content/css', '/css/v3')) .pipe(replace('../content/js', '/js/v3')) .pipe(replace('../content/images', '/images/v3')) .pipe(replace('../content/mobiscroll', '/js/v3/mobiscroll')) .pipe(replace('../content/swiper', '/js/v3/swiper')) .pipe(gulp.dest('../wap_v2/statics'));&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[display:box]]></title>
    <url>%2F2019%2F04%2F14%2Fcss%2Fdisplaybox%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 语法整理]]></title>
    <url>%2F2019%2F04%2F12%2Fother%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[因为写博客，对markdown语法不是很熟悉，每次都要网上搜，很浪费时间，所以就整理记录一下。这也是写博客的初衷，常看看，温故而知新… 引用Markdown 中引用通过符号 ‘&gt;’ 来实现。’&gt;’ 符号后的空格，可有可无。在引用的区块内，允许换行存在，换行并不会终止引用的区块。如果要结束引用，需要一行空白行，来结束引用的区块。代码如下： 123456&gt; 这是一句引用&gt; 这句仍然在引用区块内&gt;&gt; 这是一句嵌套引用&gt;&gt; 这句仍然在嵌套引用区块内&gt;&gt; 另起一行的引用。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的('&gt;')可以有可以没有。 效果如下： 这是一句引用这句仍然在引用区块内 这是一句嵌套引用这句仍然在嵌套引用区块内 另起一行的引用。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的(‘&gt;’)可以有可以没有。 注意： 结束]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 构建发布流程]]></title>
    <url>%2F2019%2F03%2F10%2Fother%2Fhexobuild%2F</url>
    <content type="text"><![CDATA[启动1$ hexo s 生成1$ hexo d -g]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年看过的电视剧]]></title>
    <url>%2F2018%2F04%2F14%2Flives%2Fdrama%2F</url>
    <content type="text"><![CDATA[少年包青天琅琊榜]]></content>
      <categories>
        <category>有关风月</category>
      </categories>
      <tags>
        <tag>电视剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看了又看]]></title>
    <url>%2F2018%2F04%2F14%2Flives%2Fmovie%2F</url>
    <content type="text"><![CDATA[海上钢琴师肖申克的救赎盗梦空间移动迷宫源代码人生遥控器闻香识女人全民目击剪刀手爱德华楚门的世界蝴蝶效应禁闭岛七宗罪飞越疯人院死神来了速度与激情让子弹飞金陵十三钗功夫美丽人生欲望之花恐怖游轮惊天魔盗团十二公民hello 树先生活着秋菊打官司]]></content>
      <categories>
        <category>有关风月</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
</search>
