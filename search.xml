<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java 学习笔记]]></title>
    <url>%2F2019%2F05%2F21%2Fjavastudy%2F</url>
    <content type="text"><![CDATA[变量在 Java 中，我们通过三个元素描述变量：变量类型、变量名以及变量值。例如: String hobby = “慕课网”; 局部变量和成员变量区别 java会给成员变量一个初始值； java不会给局部变量赋予初始值； 静态变量-静态方法静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐用类名访问~~ 静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。 如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量。 静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。 1234567891011121314151617181920212223242526272829303132333435363738// Java 中可以通过初始化块进行数据赋值。public class HelloWorld &#123; String name; // 声明变量name String sex; // 声明变量sex static int age;// 声明静态变量age // 构造方法 public HelloWorld() &#123; System.out.println(&quot;通过构造方法初始化name&quot;); name = &quot;tom&quot;; &#125; // 初始化块 &#123; System.out.println(&quot;通过初始化块初始化sex&quot;); sex = &quot;男&quot;; &#125; // 静态初始化块 static &#123; System.out.println(&quot;通过静态初始化块初始化age&quot;); age = 20; &#125; public void show() &#123; System.out.println(&quot;姓名：&quot; + name + &quot;，性别：&quot; + sex + &quot;，年龄：&quot; + age); &#125; public static void main(String[] args) &#123; // 创建对象 HelloWorld hello = new HelloWorld(); // 调用对象的show方法 &#125; &#125;// 注意: 程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于**静态初始化块只在类加载时执行一次**，所以当再次创建对象 hello2 时并未执行静态初始化块。 数据类型强类型转换double heightAvg1=176.2;int heightAvg2=(int)heightAvg1; foreach 语法for (String score:scores) { System.out.println(score);} 封装实现封装 (封装就是隐藏属性，通过方法设置获取属性) 设置private 创建getter/setter方法 在getter/setter中加入合法性判断 1234567891011121314public class Girl &#123; private Integer id; public Girl() &#123; &#125; public void setId(Integer id) &#123; // 赋值 id = id; &#125; public Integer getId() &#123; // 处理一些事情 return id; &#125;&#125; 包相关定义包 com.imooc.domain;```1导入包文件 ```import com.imooc.domain.Result; 导入全部包文件 com.imooc.domain.*;```12345678910**访问修饰符**private 自己默认 自己、妻子（同包）protected 自己、妻子、子类public 所有人都可以用**this关键字*** 指向当前对象* this.id/id 可以用来区分属性和参数 public void setId(Integer id) { // 赋值 this.id = id; this.cid = this.id;}12* 调用当前对象方法```this.getId(); 内部类内部类的主要作用如下： 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类 内部类的方法可以直接访问外部类的所有数据，包括私有的数据 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便 1234567891011121314151617181920212223//外部类HelloWorld// **定义了成员内部类后，必须使用外部类对象来创建内部类对象**public class HelloWorld &#123; // 内部类Inner，类Inner在类HelloWorld的内部 public class Inner &#123; // 内部类的方法 public void show() &#123; System.out.println(&quot;welcome to imooc!&quot;); &#125; &#125; public static void main(String[] args) &#123; // 创建外部类对象 HelloWorld hello = new HelloWorld(); // 创建内部类对象 Inner i = hello.new Inner(); // 调用内部类对象的方法 i.show(); &#125;&#125; 内部类可分为： 成员内部类访问外部类属性，HelloWorld.this.name 注意是类名，不是对象名，要加this 静态内部类 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类(); 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员 方法内部类 匿名内部类 继承 方法的重写 final 关键字 最终的意思 用了就不允许修改 用final修饰类的方法。那么方法不可以被重写 用final修饰类的属性。那么该属性要么在定义的时候就进行赋值操作 或者在构造方法中必须进行初始化。 用final修饰变量 那么定义的同时必须进行初始化成为常量！ 用final修饰类。。那么该类就不允许被继承！ super 关键字 super关键字来实现对父类成员的访问，用来引用当前对象的父类 Object 类 toString() 方法返回此对象属性值。 equals() 比较对象的引用地址是否指向同一块内存地址 多态]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传的2中方式，包含图片压缩]]></title>
    <url>%2F2019%2F04%2F30%2Fupload%2F</url>
    <content type="text"><![CDATA[代码摘自自己项目，项目框架是VUE，这里只说明功能实现，具体知识点请去MDN查看 图片转base64上传1&lt;input type="file" name="pic" id="pic" class="upload-btn" @change="uploadImg($event,'front')" accept="image/*" /&gt; 看下面代码，我们先看下FileReader对象： FileReader，查看介绍， FileReader 异步读取存储在用户计算机上的文件 当 FileReader 读取文件的方式为 readAsArrayBuffer, readAsBinaryString, readAsDataURL 或者 readAsText 的时候，会触发一个 load 事件。从而可以使用 FileReader.onload 属性对该事件进行处理。 这里会用到load属性 和readAsDataURL()方法 123456789uploadImg(e,type) &#123; let that = this let file = e.target.files[0] let reader = new FileReader() reader.readAsDataURL(file) reader.onload = function(e) &#123; // 当 FileReader 读取文件的方式为 readAsArrayBuffer, readAsBinaryString, readAsDataURL 或者 readAsText 的时候，会触发一个 load 事件 console.log(this.result) // 生成base64 &#125;&#125; 运用formData文件流上传1&lt;input type="file" name="pic" id="pic" class="upload-btn" @change="uploadImg($event,'front')" accept="image/*" /&gt; 这里会用到URL对象和formData对象，包含了图片压缩，代码注释中会说明一些自己的理解，若有偏颇，欢迎指正 URL对象相关内容请移步这里 formData对象请移步这里,formData我的理解是可以用ajax形式模拟form表单发送数据 图片压缩我们单独一个模块说明 123456789101112131415161718192021222324252627282930313233343536373839// 上传身份证图片 uploadImg(e,type) &#123; let that = this let file = e.target.files[0] lrz(file,&#123;quality: 0.6,width: 800&#125;) .then(function (rst) &#123; // 压缩成功会执行，这里的rst是压缩后图片的结果，我看了下大概压缩率能达到70%，10MB可以压缩到2MB console.log(rst); if (type == 'front')&#123; that.frontImgUrl = URL.createObjectURL(rst.file) // 这里我的理解是生成了一个图片的url that.frontImg = rst.file // 这是要发送给后端的数据 &#125; else &#123; that.backImgUrl = URL.createObjectURL(rst.file) that.backImg = rst.file &#125; &#125;) .catch(function (err) &#123; // 处理失败会执行 console.log(err) &#125;) &#125;, submit() &#123; let that = this // 创建FormData对象，并且把要传给后端的参数append进去 let formdata = new FormData(); formdata.append('id',patient.id); formdata.append('frontImg',this.frontImg); formdata.append('backImg',this.backImg); // Fetch是我封装的axios，这里可以忽略，这里重要的就是组装formdata数据 Fetch(&#123; url: "/api/xxxxx", method: "post", data: formdata &#125;).then(response =&gt; &#123; that.$router.push("aaa"); &#125;).catch(error =&gt; &#123; console.log(error); &#125;); &#125; 图片压缩 图片压缩应该是图片上传必然会遇到的问题，如果图片过大，上传慢且容易失败。我们遇到的问题是图片太大后端无法响应。 因为以前用过这个压缩库，所以这次拿出来说下，也比较简单 图片压缩代码github地址请点击 参数配置, 这里也讲的很清楚，不在赘述 12345678910111213lrz(this.files[0],&#123; // 这里会涉及到&#125;).then(function (rst) &#123; // 处理成功会执行 console.log(rst);&#125;).catch(function (err) &#123; // 处理失败会执行&#125;).always(function () &#123; // 不管是成功失败，都会执行&#125;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序checkbox样式修改]]></title>
    <url>%2F2019%2F04%2F30%2Fwxcheck%2F</url>
    <content type="text"><![CDATA[原文 微信小程序checkbox样式修改1234567891011121314151617181920212223242526/*checkbox 整体大小 */checkbox &#123; width: 240rpx; height: 90rpx;&#125;/*checkbox 选项框大小 */checkbox .wx-checkbox-input &#123; width: 50rpx; height: 50rpx;&#125;/*checkbox选中后样式 */checkbox .wx-checkbox-input.wx-checkbox-input-checked &#123; background: #FF525C;&#125;/*checkbox选中后图标样式 */checkbox .wx-checkbox-input.wx-checkbox-input-checked::before &#123; width: 28rpx; height: 28rpx; line-height: 28rpx; text-align: center; font-size: 22rpx; color: #fff; background: transparent; transform: translate(-50%, -50%) scale(1); -webkit-transform: translate(-50%, -50%) scale(1);&#125; 效果如下]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重，删除数组指定值]]></title>
    <url>%2F2019%2F04%2F30%2Farray-algorithm%2F</url>
    <content type="text"><![CDATA[最近在做一个自定义复选框+全选/全不选功能，涉及到一些数组的处理,自定义复选框 数组去重123456789uniq: function(array) &#123; var temp = []; //一个新的临时数组 for (var i = 0; i &lt; array.length; i++) &#123; if (temp.indexOf(array[i]) == -1) &#123; temp.push(array[i]); &#125; &#125; return temp;&#125; 1234// es6中新增的数据结构Setconst set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4] 删除指定数组1234567// 数组移除值remove: function(array, val) &#123; var index = array.indexOf(val); if (index &gt; -1) &#123; array.splice(index, 1); &#125;&#125; 数组排序123456789// 数组移除值var arr = new Array(6) arr[0] = "10" arr[1] = "5" arr[2] = "40" arr[3] = "25" arr[4] = "1000" arr[5] = "1"console.log(arr.sort((a,b)=&gt;&#123;return b-a&#125;))]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义复选框+全选/全不选]]></title>
    <url>%2F2019%2F04%2F30%2Fcheckout%2F</url>
    <content type="text"><![CDATA[最近在做一个自定义复选框+全选/全不选功能，项目基于vue，现在整理如下 大致思路 声明一个空的数组checked，数据为list 选中：把选中的项的id push进checked; 取消选中：判断当前id是否在checked中，若存在删除当前id 全选功能: 遍历数组，取到所有id，push进checked 全不选：checked重置为空数组 全选按钮状态：判断checked数组的长度是否和数据list长度一致，若一致则为全选状态，则给class加active 复选框状态：用indexOf是否大于-1判断当前id是否存在checked中，若大于-1，则给class加active 自定义全选功能代码123456789101112&lt;!-- 全选按钮 --&gt;&lt;div class="check all" :class="list.length == currChecked.length ?'active':''" @click="checkBoxAll"&gt;全选&lt;/div&gt;&lt;!-- 复选框 --&gt;&lt;div class="check" :class="currChecked.indexOf(item.id) &gt; -1 ? 'active':'a'" @click="checkBox(currChecked,item.id)"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536// data: &#123; list: [], // 全部选中的值 currChecked: [] // 当前已选中的复选框&#125;,methods: &#123; // 点击复选框 checkBox: function(array, id) &#123; if (array.indexOf(id) == -1) &#123; array.push(id); &#125; else &#123; this.remove(array, id); &#125; &#125;, // 全选按钮 checkBoxAll: function() &#123; let currChecked = this.currChecked let list = this.list if (currChecked.length == list.length) &#123; currChecked = []; &#125; else &#123; currChecked = []; for (var i = 0; i &lt; list.length; i++) &#123; currChecked.push(list[i].id); &#125; &#125; return currChecked; &#125;, // 数组移除值 remove: function(array, val) &#123; var index = array.indexOf(val); if (index &gt; -1) &#123; array.splice(index, 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些令人难忘的框架]]></title>
    <url>%2F2019%2F04%2F29%2Fframework%2F</url>
    <content type="text"><![CDATA[JquerygreensockaltTemplate]]></content>
      <categories>
        <category>framework</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var、const、let区别]]></title>
    <url>%2F2019%2F04%2F19%2Fjsvar%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXJS学习笔记]]></title>
    <url>%2F2019%2F04%2F19%2Frxjs%2F</url>
    <content type="text"></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp使用记录]]></title>
    <url>%2F2019%2F04%2F18%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp介绍gulp是一个前端自动化构建工具，前端开发者可以使用它来处理常见任务: 搭建web服务器 文件保存时自动重载浏览器 使用css预处理器如Sass、LESS 优化资源，比如压缩CSS、JavaScript、压缩图片、合并文件 资源文件加版本号，刷新加载最新资源，保证资源文件实时更新 gulp入门指南 这部分内容来源于中文官方文档 全局安装 gulp：1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装，这里为了举例安装gulp和gulp-clean，gulp-clean可以用来清空指定文件夹： 1$ npm install --save-dev gulp gulp-clean 在项目根目录下创建一个名为 gulpfile.js 的文件，点击可以查看gulp-clean使用方法： 12345678910var gulp = require('gulp')、 clean = require('gulp-clean') //清空文件夹,这里gulp.task('default', function() &#123; // 将你的默认的任务代码放在这&#125;);//清除dist文件夹gulp.task('clean',function()&#123; return gulp.src('dist', &#123;read: false&#125;) .pipe(clean());&#125;) 运行gulp： 1$ gulp 默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。想要单独执行特定的任务（task），请输入 gulp &lt;task&gt; &lt;othertask&gt;： 1$ gulp clean 接下来介绍下gulp相关的API，gulp的API有.src、.watch、.dest、.task。 gulp API 文档这里只简单介绍用法，和自己理解，官方文档讲解的更为详细，如果想深入学习，请移步官方文档 gulp.src(globs[, options]) 匹配想要处理的文件，例如： 1gulp.src('client/js/*.js') // 对clent/js下面的所有js文件进行处理 gulp.dest(path[, options]) dest就是要把处理完的文件放到指定位置，例如： 12gulp.src('client/js/*.js') // 对clent/js下面的所有js文件进行处理 .pipe(gulp.dest("dist/js/")); // 把处理完的文件放到`dist/js/`这个目录下面 因为有同事问过pipe方法，这里顺便提下。可以给他理解成一个管道，文件通过管道流入，可能有很多管道相连，每个管道处理不同的事物，a管道负责压缩js，b管道负责修改文件名为jquery.min.js，最后处理完就是压缩后的文件名为jquery.min.js的文件 关于pipe可以点击这里查看stream.pipe()，具体不在阐述。 gulp.task(name[, deps], fn) task定义任务，你要做什么，就是用它定义，例如要定义一个压缩js的任务，代码如下 12345678var gulp = require('gulp'), // gulp基础库 uglify = require('gulp-uglify') //压缩Js// 压缩JSgulp.task('uglifyJs',function()&#123; // 定义名为uglifyJs的任务，用来压缩js gulp.src("src/content/js/**/*.js") // 需要压缩的文件是src目录下 .pipe(uglify()) // 压缩js .pipe(gulp.dest("dist/content/js/")); // 压缩完成后放到dist目录下&#125;) 如果想执行这个任务，在终端输入以下命令： 1$ gulp uglifyJs gulp.watch(glob[, opts], tasks) 监听文件变化，如下代码/js/目录下的文件有任何变化，都会执行function 123gulp.watch('js/**/*.js', function(event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');&#125;); 常用插件及说明123456789101112gulp-sass // SCSS编译gulp-sourcemaps // SCSS地图gulp-clean // 清空文件夹gulp-clean-css // 压缩CSSgulp-uglify // 压缩Jsgulp-concat // 合并文件gulp-rev // 文件加版本号gulp-rev-collector // 替换html中资源文件gulp-minify-html // 压缩htmlgulp-replace // 替换html中的内容gulp-modify-css-urls // 修改css中url路径gulp-rename // 重命名文件 实战代码是自己项目中，根据需求配置的，有点乱，如有不明白的，欢迎留言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193'use strict';var gulp = require('gulp'), //基础库 scss = require('gulp-sass'), //SCSS编译 sourcemaps = require('gulp-sourcemaps'), //SCSS地图 clean = require('gulp-clean'), //清空文件夹 cleanCss = require('gulp-clean-css'), //压缩CSS uglify = require('gulp-uglify'), //压缩Js concat = require('gulp-concat'), //合并文件 rev = require('gulp-rev'), //文件加版本号 revCollector = require('gulp-rev-collector'), //替换html文件 minifyHTML = require('gulp-minify-html'), //压缩html replace = require('gulp-replace'), //替换html内容 // browserSync = require('browser-sync').create(), // // reload = browserSync.reload, // modifyCssUrls = require('gulp-modify-css-urls'), //修改css中url路径 rename = require('gulp-rename'); //重命名文件var jsSrc = [ // 压缩js按照次序合并 'src/content/js/base_dev/config.js', 'src/content/js/base_dev/ajax.js', 'src/content/js/base_dev/cookie.js', 'src/content/js/base_dev/jiao.js', 'src/content/js/base_dev/log.js', 'src/content/js/base_dev/second-page.js', 'src/content/js/base_dev/storage.js', 'src/content/js/base_dev/string.js', 'src/content/js/base_dev/template-helper.js', 'src/content/js/base_dev/tools.js', 'src/content/js/base_dev/common.js', 'src/content/js/base_dev/tongji.js', // 'src/content/js/base_dev/wechat.js' ], revSrc = [ // 加版本号的资源 'dist/**', '!dist/**/*.html', '!dist/content/swiper/**', '!dist/content/mobiscroll/**', '!dist/content/font/**', '!dist/**/*.json', '!dist/**/*.ico', '!dist/**/*.map', ];// 将你的默认的任务代码放在这gulp.task('default',['clean','copyDist','cleanAvail','rev','cleanCss','uglifyJs','revCollector'], function() &#123;&#125;);// 编译Scssgulp.task('scss',function()&#123; return gulp.src('src/content/scss/*.scss') .pipe(sourcemaps.init()) .pipe(scss().on('error',scss.logError)) .pipe(sourcemaps.write()) .pipe(gulp.dest('src/content/css/'));&#125;)// 合并jsgulp.task('concatJs', function() &#123; return gulp.src(jsSrc) .pipe(concat('global.js')) //合并所有js到global.js .pipe(gulp.dest('src/content/js/base/')) //输出main.js到文件夹&#125;);// 监听任务gulp.task('watch',function()&#123; var watcher = gulp.watch(['src/content/scss/**','src/index.html','src/content/js/base_dev/*.js'], ['scss','concatJs']); watcher.on('change', function(event) &#123; console.log('File ' + event.path + ' was ' + event.type + ', running tasks...'); &#125;);&#125;)//清除文件夹gulp.task('clean',function()&#123; return gulp.src('dist', &#123;read: false&#125;) .pipe(clean());&#125;)// 压缩CSSgulp.task('cleanCss',['rev'],function()&#123; gulp.src("dist/content/css/*.css") // .pipe(rename(&#123; // dirname: "../dist/content/css/", // basename: "shu", // prefix: "", // suffix: ".min", // extname: ".css" // &#125;)) .pipe(cleanCss()) .pipe(gulp.dest("dist/content/css/"));&#125;)// 压缩CSSgulp.task('cleanCssToV2',function()&#123; gulp.src("src/content/css/*.css") // 替换css文件中的images路径 .pipe(modifyCssUrls(&#123; modify: function (url, filePath) &#123; if (url.indexOf('../images') != -1) &#123; return url.replace('../images','/images/v3') &#125; if (url.indexOf('../font') != -1) &#123; return url.replace('../font','../../fonts/v3') &#125; &#125;, &#125;)) .pipe(rename(&#123; dirname: "../../wap_v2/css/v3", prefix: "", suffix: ".min", extname: ".css" &#125;)) .pipe(cleanCss()) .pipe(gulp.dest('src'));&#125;)// 压缩JSgulp.task('uglifyJs',['rev'],function()&#123; gulp.src("dist/content/js/**/*.js") .pipe(uglify()) .pipe(gulp.dest("dist/content/js/"));&#125;)// 文件加版本号gulp.task('rev',['cleanAvail'],function()&#123; return gulp.src(revSrc) .pipe(rev()) .pipe(gulp.dest('dist')) .pipe(rev.manifest()) .pipe(gulp.dest('dist'));&#125;)// 替换html中的文件路径，并压缩htmlgulp.task('revCollector', ['rev'], function () &#123; return gulp.src(['dist/rev-manifest.json', 'dist/**/*.html']) .pipe( revCollector() ) .pipe( minifyHTML(&#123; empty:true, spare:true &#125;) ) .pipe( gulp.dest('dist') );&#125;);// 复制dist文件夹gulp.task('copyDist',['clean'],function()&#123; return gulp.src('src/**') .pipe(gulp.dest('dist'))&#125;)// 清除线上不用文件，scss，base-dev等gulp.task('cleanAvail',['copyDist'],function()&#123; return gulp.src(['dist/content/scss','dist/content/js/base_dev']) .pipe(clean());&#125;)// 构建gulp.task('build',['clean','copyDist','cleanAvail','cleanCss','rev','revCollector'],function()&#123;&#125;)// 静态服务器// gulp.task('browser-sync', function() &#123;// browserSync.init(&#123;// server: &#123;// baseDir: "src/index.html"// &#125;// &#125;);// &#125;);// 代理// gulp.task('browser-sync', function() &#123;// browserSync.init(&#123;// proxy: "你的域名或IP"// &#125;);// &#125;);// 生成对应文件到v2gulp.task('fileToV2',['cssToV2','jsToV2','imgToV2','htmlToV2'],function()&#123;&#125;)gulp.task('cssToV2',function()&#123; gulp.src("dist/content/css/*.css") // 替换css文件中的images路径 .pipe(modifyCssUrls(&#123; modify: function (url, filePath) &#123; if (url.indexOf('../images') != -1) &#123; return url.replace('../images','/images/v3') &#125; if (url.indexOf('../font') != -1) &#123; return url.replace('../font','../../fonts/v3') &#125; &#125;, &#125;)) .pipe(gulp.dest('../wap_v2/css/v3'));&#125;)gulp.task('jsToV2',function()&#123; gulp.src(["!dist/content/js/cycle/**","!dist/content/js/index/**","dist/content/js/**/*.js"]) .pipe(gulp.dest('../wap_v2/js/v3'));&#125;)gulp.task('imgToV2',function()&#123; gulp.src("dist/content/images/**") .pipe(gulp.dest('../wap_v2/images/v3'));&#125;)gulp.task('htmlToV2',function()&#123; gulp.src("dist/**/*.html") // 替换css文件中的images路径 .pipe(replace('../content/css', '/css/v3')) .pipe(replace('../content/js', '/js/v3')) .pipe(replace('../content/images', '/images/v3')) .pipe(replace('../content/mobiscroll', '/js/v3/mobiscroll')) .pipe(replace('../content/swiper', '/js/v3/swiper')) .pipe(gulp.dest('../wap_v2/statics'));&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[display:box]]></title>
    <url>%2F2019%2F04%2F14%2Fdisplaybox%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 语法整理]]></title>
    <url>%2F2019%2F04%2F12%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[因为写博客，对markdown语法不是很熟悉，每次都要网上搜，很浪费时间，所以就整理记录一下。这也是写博客的初衷，常看看，温故而知新… 引用Markdown 中引用通过符号 ‘&gt;’ 来实现。’&gt;’ 符号后的空格，可有可无。在引用的区块内，允许换行存在，换行并不会终止引用的区块。如果要结束引用，需要一行空白行，来结束引用的区块。代码如下：123456&gt; 这是一句引用&gt; 这句仍然在引用区块内&gt;&gt; 这是一句嵌套引用&gt;&gt; 这句仍然在嵌套引用区块内&gt;&gt; 另起一行的引用。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的('&gt;')可以有可以没有。 效果如下： 这是一句引用这句仍然在引用区块内 这是一句嵌套引用这句仍然在嵌套引用区块内 另起一行的引用。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的(‘&gt;’)可以有可以没有。 注意： 结束]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[那些年看过的电视剧]]></title>
    <url>%2F2018%2F04%2F14%2Fdrama%2F</url>
    <content type="text"><![CDATA[少年包青天琅琊榜]]></content>
      <categories>
        <category>有关风月</category>
      </categories>
      <tags>
        <tag>电视剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传的2中方式]]></title>
    <url>%2F2018%2F04%2F14%2Fmovie%2F</url>
    <content type="text"><![CDATA[海上钢琴师肖申克的救赎盗梦空间移动迷宫源代码人生遥控器闻香识女人全民目击剪刀手爱德华楚门的世界蝴蝶效应禁闭岛七宗罪飞越疯人院死神来了速度与激情让子弹飞金陵十三钗功夫美丽人生欲望之花恐怖游轮惊天魔盗团十二公民hello 树先生]]></content>
      <categories>
        <category>有关风月</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
</search>
